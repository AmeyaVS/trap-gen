#labels Featured,Phase-Implementation,Phase-Deploy
summary Brief how-to explaining how it is possible to use TRAP for the generation of a new processor model.

= Introduction =

TRAP (Transactional-level Retargetable Automatic Processor) is a framework for the generation of processor simulators in C++ starting from high level descriptions. The processor description is given directly in Python by calling the APIs of the TRAP library.
Once the description of the processor is complete, you can create the C++ code implementing the processor by litterally executing the python module (among the ones describing your processor) containing the call to the _write_ API.

The rest of this document presents a short step-by-step How To on how to describe a processor using TRAP and how to create the corresponding C++ code. For a more complete example look at the description of the ARM7TDMI processor contained in folder `processor/ARM7TDMI`.


= Details =

== Describing the Architecture ==
The architecture description consists of the indication of the _registers_, _ports_, _issue width_ of the real processor. Not many information are needed in this section since we target the generation of *high level simulators* (more details would be needed, for example, for the generation of RTL code).

The following code snippets are taken from file `processor/ARM7TDMI/ARMArch.py`:
{{{
import trap
}}}
Lets import the core trap modules; note that if they are not in the standard python search path we can specify their path using the instruction `sys.path.append(_trap_path_)`.

We can then procede with the actual creation of the processor:
{{{
processor = trap.Processor('ARM7TDMI', version = 0.1, systemc = False, coprocessor = False, instructionCache = True)
processor.setLittleEndian()
processor.setWordsize(4, 8)
processor.setISA(ARMIsa.isa)
}}}
This means that the processor will be called _ARM7TDMI_ and that the current version is _0.1_. SystemC will not be used for keeping time, so all will be executed in the same delta cycle; this option is valid only for functional descriptions. Note how SystemC will not be used for keeping time, but the structure of the architectural components will anyway be based on this library. At processor construction we also indicate that we are describing a normal processor and not a coprocessor (coprocessor description is not supported by TRAP yet) and finlly we specify that the decoding instruction cache shall be used. Such a cache has nothing to do with the cache of a real processor, it is simply a buffer holding already decoding instructions in order to avoid re-decoding them. The use of the decoding cache consistently speeds up simulation.
The other two instructions are self-explanatory: we are going to describe a _little endian_ system with _4_ bytes per word, _8_ bits per byte. Finally the class hodling the _Instruction Set Architecture (ISA)_ Description is indicated.

Now we can start describing the architectural elements:
{{{
regBank = trap.RegisterBank('RB', 30, 32)
processor.addRegBank(regBank)
cpsrBitMask = {'N': (31, 31), 'Z': (30, 30), 'C': (29, 29), 'V': (28, 28), 'I': (7, 7), 'F': (6, 6), 'mode': (0, 3)}
cpsr = trap.Register('CPSR', 32, cpsrBitMask)
cpsr.setDefaultValue(0x000000D3)
processor.addRegister(cpsr)
}}}
Here we create a register bank (a group of registers) called _RB_ composed of _30_ registers each one _32_ bit wide. Next a single register called _CPSR_ is created: it is _32_ bit wide. Note how a mask (_cpsrBitMask_) is defined: this mask easies the access to the individual registers bits: from the ISA implementation code (see below) we can simply write `CPSR["mode"]` to access the first four bits of the regsiter. We also set a default value, which is the value that register CPSR have at processor reset; As shown below it is possible to also specify special keywords as default values.

{{{
regs = trap.AliasRegBank('REGS', 16, 'RB[0-15]')
processor.addAliasRegBank(regs)
FP = trap.AliasRegister('FP', 'REGS[12]')
processor.addAliasReg(FP)
}}}

{{{
PC = trap.AliasRegister('PC', 'REGS[15]')
PC.setDefaultValue(('ENTRY_POINT', 8))
processor.addAliasReg(PC)
}}}

{{{
idMap = trap.MemoryAlias(0xFFFFFFF0, 'MP_ID')
processor.addMemAlias(idMap)
}}}

{{{
idMap = trap.MemoryAlias(0xFFFFFFF0, 'MP_ID')
processor.addMemAlias(idMap)
}}}

{{{
processor.setFetchRegister('PC', -8)
}}}

{{{
processor.setMemory('dataMem', 10*1024*1024)
}}}

{{{
irq = trap.Interrupt('IRQ', priority = 0)
processor.addIrq(irq)
processor.setIRQOperation(ARMIsa.IRQOperation)
}}}

{{{
fetchStage = trap.PipeStage('fetch')
processor.addPipeStage(fetchStage)
decodeStage = trap.PipeStage('decode')
processor.addPipeStage(decodeStage)
executeStage = trap.PipeStage('execute')
processor.addPipeStage(executeStage)
}}}

{{{
abi = trap.ABI('REGS[0]', 'REGS[0-3]', 'PC', 'LR', 'SP', 'FP')
abi.addVarRegsCorrespondence({'REGS[0-15]': (0, 15), 'CPSR': (25, 25)})
abi.setOffset('PC', -8)
abi.setOffset('REGS[15]', -8)
processor.setABI(abi)
}}}

{{{
processor.write(folder = 'processor', models = ['funcLT'])
}}}

== Describing the instruction coding ==

== Describing the instruction behavior ==

== Creating the Instruction Set Simulator ==