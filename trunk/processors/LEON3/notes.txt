-- Branch: I have to check that instructions already issued to not modify the psr.icc otherwise the branch cannot
be resolved in the decode stage, but I have to wait for one or two pipeline cycles.
ES:
If there are two instructions:
A
branch
Instruction A will change the psr.icc, so is it right that one
pipeline hold should be at decode stage so that branch instruction
can get the the newest icc until A passes execute stage?
So I have to stall the pipeline for two cycles in this case, until I pass
the execute stage. Does this mean that PSR is written in the execute stage and not
in the WB one?

-- Branch instruction directly modifies not only NPC but also the program counter directly,
so there is no need for bubbles in the pipeline. Actually all instructions do so, they do not
really use the NPC register (but for easyness I can use it an simply behave differently
in the cycle accurate, where I modify both, and in the functional, where I simply modify
NPC). This also because the functional behavior of sparc V8 is:
fetch from PC
PC = nPC
nPC += 4

-- The check for the condition code (if any) to see if an instruction should be
annulled is done in the decode stage (??is this really true?? so not just branch but
all instructions with condition code are delayed if a preceding instruction is not
in fetch yet?) - actually the only instructions with condition code are the branches

-- Interrupts: the processor has in input one line of 4 bits encoding the interrupt
request level of the corresponding interrupt; the queue of interrupts is dealt with by
the interrupt controller, so I should not bother with it. Processor should be able to
acknowledge the interrupt (how?? is there a separate line?) CHECK in the VHDL code.

-- Exception stage: do we check for interrupts here? or in fetch? CHECK in the VHDL code?
from the processor manual (page 159) it seems that the check is performed in the fetch stage
and that the exception stage simply checks for exceptions and it sets a flag which triggers
the exception in the next fetch stage

-- The 8 bit ASI is appended to the 32 bits when memory is accessed (do we need to
send them on the output TLM port? and what if internal memory is used?)I think
they are dealt with inside the processor itself and never sent out...CHECK on VHDL model...
otherwise, if they are sent out, we need to accordingly modify the bus

-- Branch instruction, depending on the a bit may annull the successive instruction; in the
pipeline this just means a flush (which is the stage where the annull is done?? CHECK on
VHDL). For the functional model, this means that I also modify the PC and not just the
nPC, so the next instruction is not even fetched

-- For efficiency, shall we use constant registers, whose value is set at processor startup
and cannot be modified (e.g. r0 of the sparc processor)

-- Check when the ICC fields of the PSR are written: in the writeBack stage as normal registers or
in the execution stage? (it seems in the execute because of the number of stalls of a branch
instruction when there is a preceding instruction which modifies the ICC)

-- Check when the Y register is written: in the wb stage as normal registers or in the execute one?

-- smac e umac: are only bits 7:0 of the Y register written or all the bits are written (i.e. all set to 0
a part from 7:0 where the result is put)