-- Branch: I have to check that instructions already issued to not modify the psr.icc otherwise the branch cannot
be resolved in the decode stage, but I have to wait for one or two pipeline cycles.
ES:
If there are two instructions:
A
branch
Instruction A will change the psr.icc, so is it right that one
pipeline hold should be at decode stage so that branch instruction
can get the the newest icc until A passes execute stage?
So I have to stall the pipeline for two cycles in this case, until I pass
the execute stage. Does this mean that PSR is written in the execute stage and not
in the WB one?

-- Branch instruction directly modifies not only NPC but also the program counter directly,
so there is no need for bubbles in the pipeline. Actually all instructions do so, they do not
really use the NPC register (but for easyness I can use it an simply behave differently
in the cycle accurate, where I modify both, and in the functional, where I simply modify
NPC). This also because the functional behavior of sparc V8 is:
fetch from PC
PC = nPC
nPC += 4

-- The check for the condition code (if any) to see if an instruction should be
annulled is done in the decode stage (??is this really true?? so not just branch but
all instructions with condition code are delayed if a preceding instruction is not
in fetch yet?)

-- Interrupts: the processor has in input one line of 4 bits encoding the interrupt
request level of the corresponding interrupt; the queue of interrupts is dealt with by
the interrupt controller, so I should not bother with it. Processor should be able to
acknowledge the interrupt (how?? is there a separate line?) CHECK in the VHDL code.

-- Exception stage: do we check for interrupts here? or in fetch? CHECK in the VHDL code

-- The 8 bit ASI is appended to the 32 bits when memory is accessed (do we need to 
send them on the output TLM port? and what if internal memory is used?)I think
they are dealt with inside the processor itself and never sent out...CHECK on VHDL model

-- Branch instruction, depending on the a bit may annull the successive instruction; in the
pipeline this just means a flush (which is the stage where the annull is done?? CHECK on
VHDL). For the functional model, this means that I also modify the PC and not just the
nPC, so the next instruction is not even fetched

-- For efficiency, shall we use constant registers, whose value is set at processor startup
and cannot be modified (e.g. r0 of the sparc processor)

